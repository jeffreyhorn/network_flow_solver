#!/usr/bin/env python3
"""Script to generate the complete Jupyter notebook tutorial."""

import json

# Complete notebook cells
cells = [
    # Title and Introduction
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "# Network Flow Solver Tutorial\n",
            "\n",
            "Welcome to the interactive tutorial for the **Network Flow Solver** - a pure Python implementation of the network simplex algorithm for minimum-cost flow problems.\n",
            "\n",
            "## What You'll Learn\n",
            "\n",
            "In this tutorial, you'll learn how to:\n",
            "\n",
            "1. **Define and solve basic network flow problems**\n",
            "2. **Work with different problem types** (transportation, assignment, max flow, etc.)\n",
            "3. **Analyze solutions** using dual values and sensitivity analysis\n",
            "4. **Optimize solver performance** with configuration options\n",
            "5. **Validate and debug** solutions\n",
            "6. **Handle real-world scenarios** with incremental resolving\n",
            "\n",
            "## Prerequisites\n",
            "\n",
            "This tutorial assumes basic knowledge of:\n",
            "- Python programming\n",
            "- Linear programming concepts (optional but helpful)\n",
            "- Network/graph theory basics (nodes, arcs, flows)\n",
            "\n",
            "Let's get started!",
        ],
    },
    # Installation
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## 1. Installation and Setup\n",
            "\n",
            "First, let's install the network solver package (if not already installed):",
        ],
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# If running in a fresh environment, install the package\n",
            "# !pip install -e .\n",
            "\n",
            "# Import the main functions\n",
            "from network_solver import build_problem, solve_min_cost_flow, SolverOptions\n",
            "from network_solver import validate_flow, extract_path, compute_bottleneck_arcs\n",
            "\n",
            'print("✓ Network Flow Solver imported successfully!")',
        ],
    },
    # First Problem
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## 2. Your First Network Flow Problem\n",
            "\n",
            "Let's start with a simple transportation problem: shipping goods from warehouses to stores at minimum cost.\n",
            "\n",
            "### Problem Description\n",
            "\n",
            "- **Warehouse A** has 50 units to ship (supply = 50)\n",
            "- **Warehouse B** has 30 units to ship (supply = 30)\n",
            "- **Store 1** needs 40 units (demand = -40)\n",
            "- **Store 2** needs 40 units (demand = -40)\n",
            "\n",
            "Shipping costs:\n",
            "- Warehouse A → Store 1: $2/unit\n",
            "- Warehouse A → Store 2: $3/unit\n",
            "- Warehouse B → Store 1: $4/unit\n",
            "- Warehouse B → Store 2: $1/unit",
        ],
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Define nodes (supply/demand points)\n",
            "nodes = [\n",
            '    {"id": "warehouse_a", "supply": 50.0},\n',
            '    {"id": "warehouse_b", "supply": 30.0},\n',
            '    {"id": "store_1", "supply": -40.0},  # Negative = demand\n',
            '    {"id": "store_2", "supply": -40.0},\n',
            "]\n",
            "\n",
            "# Define arcs (shipping routes with costs)\n",
            "arcs = [\n",
            '    {"tail": "warehouse_a", "head": "store_1", "cost": 2.0, "capacity": 100.0},\n',
            '    {"tail": "warehouse_a", "head": "store_2", "cost": 3.0, "capacity": 100.0},\n',
            '    {"tail": "warehouse_b", "head": "store_1", "cost": 4.0, "capacity": 100.0},\n',
            '    {"tail": "warehouse_b", "head": "store_2", "cost": 1.0, "capacity": 100.0},\n',
            "]\n",
            "\n",
            "# Build the problem\n",
            "problem = build_problem(nodes=nodes, arcs=arcs, directed=True, tolerance=1e-6)\n",
            "\n",
            'print("✓ Problem created successfully!")\n',
            'print(f"  Nodes: {len(nodes)}")\n',
            'print(f"  Arcs: {len(arcs)}")',
        ],
    },
    # Solve the problem
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": ["### Solve the Problem\n", "\n", "Now let's find the optimal shipping plan:"],
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Solve for minimum cost\n",
            "result = solve_min_cost_flow(problem)\n",
            "\n",
            'print(f"Status: {result.status}")\n',
            'print(f"Total Cost: ${result.objective:.2f}")\n',
            'print(f"Iterations: {result.iterations}")\n',
            'print("\\nOptimal Shipping Plan:")\n',
            "for (tail, head), flow in sorted(result.flows.items()):\n",
            "    if flow > 0.01:  # Only show non-zero flows\n",
            '        print(f"  {tail:12} → {head:10}: {flow:5.1f} units")',
        ],
    },
    # Interpretation
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "### Interpreting the Results\n",
            "\n",
            "The solver found the optimal solution:\n",
            "- **Total cost**: Minimum cost to satisfy all demands\n",
            "- **Status**: `optimal` means we found the best solution\n",
            "- **Flows**: How many units to ship on each route\n",
            "\n",
            "Let's verify the solution satisfies all constraints:",
        ],
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Validate the solution\n",
            "validation = validate_flow(problem, result)\n",
            "\n",
            "if validation.is_valid:\n",
            '    print("✓ Solution is VALID!")\n',
            '    print("  All constraints satisfied:")\n',
            '    print("  - Flow conservation at each node")\n',
            '    print("  - Capacity constraints on arcs")\n',
            '    print("  - Lower bound constraints")\n',
            "else:\n",
            '    print("✗ Solution has violations:")\n',
            "    for error in validation.errors:\n",
            '        print(f"  - {error}")',
        ],
    },
    # Dual Values
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## 3. Sensitivity Analysis with Dual Values\n",
            "\n",
            "**Dual values** (also called shadow prices or node potentials) tell us the marginal cost of changing supply/demand at each node.\n",
            "\n",
            "### What Do Dual Values Mean?\n",
            "\n",
            "- **Negative dual**: It costs money to supply more at this node\n",
            "- **Positive dual**: It saves money to demand more at this node\n",
            "- **Dual difference**: Marginal cost between two nodes",
        ],
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Examine dual values (shadow prices)\n",
            'print("Dual Values (Shadow Prices):")\n',
            "for node_id, dual in sorted(result.duals.items()):\n",
            '    print(f"  {node_id:12}: ${dual:6.2f}")\n',
            "\n",
            "# Calculate marginal cost of increasing demand at Store 1\n",
            'marginal_cost = result.duals["warehouse_a"] - result.duals["store_1"]\n',
            'print(f"\\nMarginal cost to ship 1 more unit to Store 1: ${-marginal_cost:.2f}")',
        ],
    },
    # Maximum Flow Problem
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## 4. Maximum Flow Problem\n",
            "\n",
            "Let's solve a maximum flow problem (finding the maximum throughput from source to sink).\n",
            "\n",
            "**Trick**: Convert max flow to min-cost flow by:\n",
            "1. Set all arc costs to 0\n",
            "2. Add a return arc from sink to source with cost = -1\n",
            "3. Give the return arc very high capacity\n",
            "4. Minimize cost (which maximizes flow on the return arc)",
        ],
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Maximum flow network\n",
            "max_flow_nodes = [\n",
            '    {"id": "source", "supply": 0.0},\n',
            '    {"id": "a", "supply": 0.0},\n',
            '    {"id": "b", "supply": 0.0},\n',
            '    {"id": "sink", "supply": 0.0},\n',
            "]\n",
            "\n",
            "max_flow_arcs = [\n",
            "    # Forward arcs (capacity limits, zero cost)\n",
            '    {"tail": "source", "head": "a", "capacity": 10.0, "cost": 0.0},\n',
            '    {"tail": "source", "head": "b", "capacity": 5.0, "cost": 0.0},\n',
            '    {"tail": "a", "head": "sink", "capacity": 7.0, "cost": 0.0},\n',
            '    {"tail": "b", "head": "sink", "capacity": 8.0, "cost": 0.0},\n',
            '    {"tail": "a", "head": "b", "capacity": 4.0, "cost": 0.0},\n',
            "    # Return arc (maximizing this is equivalent to maximizing flow)\n",
            '    {"tail": "sink", "head": "source", "capacity": 1000.0, "cost": -1.0},\n',
            "]\n",
            "\n",
            "max_flow_problem = build_problem(\n",
            "    nodes=max_flow_nodes, arcs=max_flow_arcs, directed=True, tolerance=1e-6\n",
            ")\n",
            "max_flow_result = solve_min_cost_flow(max_flow_problem)\n",
            "\n",
            "# Maximum flow is the flow on the return arc\n",
            'max_flow_value = max_flow_result.flows.get(("sink", "source"), 0.0)\n',
            "\n",
            'print(f"Maximum Flow: {max_flow_value:.1f} units")\n',
            'print("\\nFlow on each arc:")\n',
            "for (tail, head), flow in sorted(max_flow_result.flows.items()):\n",
            '    if flow > 0.01 and head != "source":  # Exclude return arc\n',
            '        print(f"  {tail:6} → {head:6}: {flow:5.1f} units")',
        ],
    },
    # Solver Configuration
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## 5. Solver Configuration and Performance\n",
            "\n",
            "You can tune the solver for your specific problem using `SolverOptions`:\n",
            "\n",
            '- **`pricing_strategy`**: "devex" (default, fewer iterations) or "dantzig" (simpler)\n',
            "- **`ft_update_limit`**: How often to rebuild basis (default: 64)\n",
            "- **`block_size`**: Devex pricing block size\n",
            "- **`tolerance`**: Numerical precision (default: 1e-6)\n",
            "- **`max_iterations`**: Iteration limit",
        ],
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "import time\n",
            "\n",
            "# Compare Devex vs Dantzig pricing\n",
            'print("Comparing pricing strategies:\\n")\n',
            "\n",
            'for strategy in ["devex", "dantzig"]:\n',
            "    options = SolverOptions(pricing_strategy=strategy)\n",
            "    \n",
            "    start = time.perf_counter()\n",
            "    result = solve_min_cost_flow(problem, options=options)\n",
            "    elapsed = time.perf_counter() - start\n",
            "    \n",
            '    print(f"{strategy.capitalize():7}: {result.iterations:3} iterations, {elapsed*1000:6.2f} ms")',
        ],
    },
    # Incremental Resolving
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## 6. Incremental Resolving (What-If Analysis)\n",
            "\n",
            "Often you need to solve similar problems with small changes (e.g., demand fluctuations, capacity changes).\n",
            "\n",
            "Let's see what happens if we increase demand at Store 1:",
        ],
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Original problem\n",
            "original_cost = result.objective\n",
            'print(f"Original cost: ${original_cost:.2f}")\n',
            "\n",
            "# Increase demand at Store 1 by 10 units\n",
            "modified_nodes = [\n",
            '    {"id": "warehouse_a", "supply": 50.0},\n',
            '    {"id": "warehouse_b", "supply": 40.0},  # +10 supply\n',
            '    {"id": "store_1", "supply": -50.0},     # +10 demand\n',
            '    {"id": "store_2", "supply": -40.0},\n',
            "]\n",
            "\n",
            "modified_problem = build_problem(nodes=modified_nodes, arcs=arcs, directed=True, tolerance=1e-6)\n",
            "modified_result = solve_min_cost_flow(modified_problem)\n",
            "\n",
            "cost_change = modified_result.objective - original_cost\n",
            'print(f"Modified cost: ${modified_result.objective:.2f}")\n',
            'print(f"Cost increase: ${cost_change:.2f} (${cost_change/10:.2f} per unit)")\n',
            "\n",
            "# Compare with dual value prediction\n",
            'predicted_change = 10 * (result.duals["warehouse_b"] - result.duals["store_1"])\n',
            'print(f"\\nPredicted from duals: ${-predicted_change:.2f}")\n',
            "print(f\"Prediction accuracy: {abs(predicted_change + cost_change) < 0.01 and '✓ Exact!' or '≈ Close'}\")",
        ],
    },
    # Bottleneck Analysis
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## 7. Bottleneck Analysis\n",
            "\n",
            "Identify which arcs are capacity-constrained (operating near full capacity):",
        ],
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Find bottlenecks (arcs at ≥90% capacity)\n",
            "bottlenecks = compute_bottleneck_arcs(problem, result, threshold=0.90)\n",
            "\n",
            "if bottlenecks:\n",
            '    print(f"Found {len(bottlenecks)} bottleneck(s):\\n")\n',
            "    for bn in bottlenecks:\n",
            '        print(f"  {bn.tail} → {bn.head}:")\n',
            '        print(f"    Flow: {bn.flow:.1f} / Capacity: {bn.capacity:.1f}")\n',
            '        print(f"    Utilization: {bn.utilization*100:.1f}%")\n',
            '        print(f"    Slack: {bn.slack:.1f} units\\n")\n',
            "else:\n",
            '    print("No bottlenecks found (all arcs have >10% spare capacity)")',
        ],
    },
    # Visualization
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## 8. Visualizing the Network (Optional)\n",
            "\n",
            "You can visualize the network and solution using matplotlib and networkx:",
        ],
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "try:\n",
            "    import matplotlib.pyplot as plt\n",
            "    import networkx as nx\n",
            "    \n",
            "    # Create directed graph\n",
            "    G = nx.DiGraph()\n",
            "    \n",
            "    # Add nodes\n",
            "    for node in nodes:\n",
            '        G.add_node(node["id"], supply=node["supply"])\n',
            "    \n",
            "    # Add edges with flow\n",
            "    for (tail, head), flow in result.flows.items():\n",
            "        if flow > 0.01:\n",
            "            G.add_edge(tail, head, flow=flow, weight=flow)\n",
            "    \n",
            "    # Layout and draw\n",
            "    pos = nx.spring_layout(G, k=2, iterations=50)\n",
            "    \n",
            "    plt.figure(figsize=(10, 6))\n",
            "    \n",
            "    # Draw nodes (color by supply/demand)\n",
            "    node_colors = ['lightgreen' if G.nodes[n].get('supply', 0) > 0 \n",
            "                   else 'lightcoral' if G.nodes[n].get('supply', 0) < 0 \n",
            "                   else 'lightblue' for n in G.nodes()]\n",
            "    \n",
            "    nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=2000, alpha=0.9)\n",
            "    nx.draw_networkx_labels(G, pos, font_size=10, font_weight='bold')\n",
            "    \n",
            "    # Draw edges (width proportional to flow)\n",
            "    edges = G.edges()\n",
            "    weights = [G[u][v]['flow']/10 for u, v in edges]\n",
            "    nx.draw_networkx_edges(G, pos, width=weights, alpha=0.6, arrows=True, arrowsize=20)\n",
            "    \n",
            "    # Edge labels (show flow)\n",
            "    edge_labels = {(u, v): f\"{G[u][v]['flow']:.0f}\" for u, v in edges}\n",
            "    nx.draw_networkx_edge_labels(G, pos, edge_labels, font_size=8)\n",
            "    \n",
            "    plt.title(f\"Optimal Flow Solution (Total Cost: ${result.objective:.2f})\", fontsize=14, fontweight='bold')\n",
            "    plt.axis('off')\n",
            "    plt.tight_layout()\n",
            "    plt.show()\n",
            "    \n",
            "except ImportError:\n",
            '    print("📊 Install matplotlib and networkx to visualize: pip install matplotlib networkx")',
        ],
    },
    # Summary
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## 9. Summary and Next Steps\n",
            "\n",
            "### What You've Learned\n",
            "\n",
            "✓ **Basic problem formulation**: Nodes (supply/demand) and arcs (cost/capacity)\n",
            "\n",
            "✓ **Solving problems**: `build_problem()` + `solve_min_cost_flow()`\n",
            "\n",
            "✓ **Solution validation**: `validate_flow()` to check constraints\n",
            "\n",
            "✓ **Sensitivity analysis**: Using dual values to understand marginal costs\n",
            "\n",
            "✓ **Maximum flow**: Converting max flow to min-cost flow\n",
            "\n",
            "✓ **Solver configuration**: Tuning with `SolverOptions`\n",
            "\n",
            "✓ **Incremental resolving**: What-if analysis with problem modifications\n",
            "\n",
            "✓ **Bottleneck analysis**: Finding capacity-constrained arcs\n",
            "\n",
            "### Where to Go Next\n",
            "\n",
            "1. **Examples directory**: Check `examples/` for more scenarios:\n",
            "   - `sensitivity_analysis_example.py` - Dual values and shadow prices\n",
            "   - `incremental_resolving_example.py` - Scenario analysis\n",
            "   - `performance_profiling_example.py` - Performance optimization\n",
            "   - `undirected_graph_example.py` - Undirected networks\n",
            "\n",
            "2. **Documentation**: See `docs/` for detailed guides:\n",
            "   - `docs/algorithm.md` - Network simplex algorithm explanation\n",
            "   - `docs/api.md` - Complete API reference\n",
            "   - `docs/examples.md` - Comprehensive examples\n",
            "   - `docs/benchmarks.md` - Performance characteristics\n",
            "\n",
            "3. **Advanced topics**:\n",
            "   - Progress monitoring with callbacks\n",
            "   - Structured logging for production systems\n",
            "   - Custom problem generation and testing\n",
            "\n",
            "### Try It Yourself!\n",
            "\n",
            "Experiment with:\n",
            "- Different network structures\n",
            "- Varying costs and capacities\n",
            "- Larger problems (100+ nodes)\n",
            "- Real-world datasets\n",
            "\n",
            "Happy optimizing! 🚀",
        ],
    },
]

# Create complete notebook
notebook = {
    "cells": cells,
    "metadata": {
        "kernelspec": {"display_name": "Python 3", "language": "python", "name": "python3"},
        "language_info": {
            "codemirror_mode": {"name": "ipython", "version": 3},
            "file_extension": ".py",
            "mimetype": "text/x-python",
            "name": "python",
            "nbconvert_exporter": "python",
            "pygments_lexer": "ipython3",
            "version": "3.12.0",
        },
    },
    "nbformat": 4,
    "nbformat_minor": 5,
}

# Write to file
output_path = "network_flow_tutorial.ipynb"
with open(output_path, "w") as f:
    json.dump(notebook, f, indent=1)

print(f"✓ Created {output_path}")
print(f"  Total cells: {len(cells)}")
print(f"  Markdown cells: {sum(1 for c in cells if c['cell_type'] == 'markdown')}")
print(f"  Code cells: {sum(1 for c in cells if c['cell_type'] == 'code')}")
